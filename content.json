{"posts":[{"title":"C语言中的结构体对齐","text":"例子12345678#pragma pack(2)typedef struct _st{ uint8_t a; uint32_t b; uint16_t c;}__attribute__((aligned(16))) st;#pragma pack() hello结构体的大小为 16, 因为c语言中结构体的大小遵循三大原则. 原则 成员在其大小倍数的位置访问速度最快 使用#pragma pack(m)来限制内部紧凑性 使用__attribute__((aligned(n)))来限制外部对齐 推理 仅考虑原则1， 则a在0, b在4, c在8; 整体大小应该为10; 结合原则2， pack(2)表示按照2的倍数进行处理， 尽可能内部紧凑。则a在0, b在2, c在6; 整体大小应该为8; 结合原则3， aligned(16)表示结构整体应当按16外部对齐, 则偏移不变，但是整体大小应该为16; 答疑 如果不设置, pack和aligned是多少？ 答：与编译器和目标架构有关。 {uint8_t, uint16_t} , pack(8), aligned(1) 该配置下为什么大小为4, 不应该为8吗？ 答：pack(8)约束太宽松。成员最大为4字节，按照原则1已经满足约束条件。 {uint8_t, uint16_t, uint8_t} , pack(2), aligned(1) 该配置下为什么大小为6, 不应该为5吗？ 答：原因在于最后存在一个补足位；该补足位不是因为pack(2), pack是为了紧凑，不补足既满足pack(2)又紧凑不是更好，同时aligned(1)保证外部对此没有要求。补足是因为第二位的uint16_t和原则1，对于单个st其大小为5当然没问题。原因在于原则1，当存在st[10]这种数组时，访问第一个元素没问题符合原则1，但是访问第二个元素的第二个成员就会出现奇地址，显然不满足原则1，因此需要补全一个字节。","link":"/blog/2023/02/09/c-struct-size/"},{"title":"使用Github Pages和Hexo搭建博客，利用Github Action实现自动部署","text":"搭建博客Hexo官方搭建教程就完全足够了，遇到问题再Google。 利用Github Action 实现自动部署Hexo官方部署教程也完全足够。","link":"/blog/2023/02/09/pages-hexo-action/"}],"tags":[{"name":"编程","slug":"编程","link":"/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"c","slug":"c","link":"/blog/tags/c/"},{"name":"运维","slug":"运维","link":"/blog/tags/%E8%BF%90%E7%BB%B4/"}],"categories":[],"pages":[]}