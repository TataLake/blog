{"posts":[{"title":"C语言中的结构体对齐","text":"例子12345678#pragma pack(2)typedef struct _st{ uint8_t a; uint32_t b; uint16_t c;}__attribute__((aligned(16))) st;#pragma pack() hello结构体的大小为 16, 因为c语言中结构体的大小遵循三大原则. 原则 成员在其大小倍数的位置访问速度最快 使用#pragma pack(m)来限制内部紧凑性 使用__attribute__((aligned(n)))来限制外部对齐 推理 仅考虑原则1， 则a在0, b在4, c在8; 整体大小应该为10; 结合原则2， pack(2)表示按照2的倍数进行处理， 尽可能内部紧凑。则a在0, b在2, c在6; 整体大小应该为8; 结合原则3， aligned(16)表示结构整体应当按16外部对齐, 则偏移不变，但是整体大小应该为16; 答疑 如果不设置, pack和aligned是多少？ 答：与编译器和目标架构有关。 {uint8_t, uint16_t} , pack(8), aligned(1) 该配置下为什么大小为4, 不应该为8吗？ 答：pack(8)约束太宽松。成员最大为4字节，按照原则1已经满足约束条件。 {uint8_t, uint16_t, uint8_t} , pack(2), aligned(1) 该配置下为什么大小为6, 不应该为5吗？ 答：原因在于最后存在一个补足位；该补足位不是因为pack(2), pack是为了紧凑，不补足既满足pack(2)又紧凑不是更好，同时aligned(1)保证外部对此没有要求。补足是因为第二位的uint16_t和原则1，对于单个st其大小为5当然没问题。原因在于原则1，当存在st[10]这种数组时，访问第一个元素没问题符合原则1，但是访问第二个元素的第二个成员就会出现奇地址，显然不满足原则1，因此需要补全一个字节。","link":"/blog/2023/02/24/c-struct-size/"},{"title":"健康管理","text":"前言之前对于健康的认识一直为三部分: 1. 睡眠 2. 饮食 3. 运动. 今天又认识到另外一个重要成分: 念头. 睡眠关于睡眠, 遵循”日出而作, 日落而息”的规律大致是没什么错的. 可能足够的睡眠而不考虑具体时刻也是OK的, 但是本人无法获取足够例证. 饮食这部分直接参考联合国粮食及农业组织发布的食源性膳食指南 运动可参考PAI, 个人运动机能指数 念头中医:喜伤心, 怒伤肝, 忧伤肺, 思伤脾, 恐伤肾; 西方研究冥想具有减轻压力、抑郁和焦虑，提升专注力，记忆力和创造力，改善睡眠，戒掉各种瘾，缓解身体疼痛，增强免疫力等. 虽说上面对于情绪念头的说法有点神乎其神, 但是容易知道的是强烈的情绪会使引起激素剧烈变化.","link":"/blog/2023/02/24/health/"},{"title":"内存屏障","text":"DMBDMB, 全称Data Memory Barrier(数据内存屏障)。先看ARMv7-M Architecture Reference Manual手册中的说明。 Data Memory Barrier acts as a memory barrier. It ensures that all explicit memory accesses that appear inprogram order before the DMB instruction are observed before any explicit memory accesses that appear inprogram order after the DMB instruction. It does not affect the ordering of any other instructions executing onthe processor. 其中Memory Access的定义为读写，既包括读也包括写。 (computer science) the operation of reading or writing stored information 因此，DMB的作用为保证DMB前的内存读写一定发生在DMB后，但是并不保证其它指令的执行顺序。 DSB Data Synchronization Barrier acts as a special kind of memory barrier. No instruction in program order after thisinstruction can execute until this instruction completes. This instruction completes only when both: • Any explicit memory access made before this instruction is complete • The side-effects of any SCS access that performs a context-altering operation are visible. DSB与DMB类似，作用更加明显，保证DSB前的所有指令在DSB之前都执行。 ISB Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISBare fetched from cache or memory after the instruction has completed. It ensures that the effects of context alteringoperations, such as those resulting from read or write accesses to the System Control Space (SCS), that completedbefore the ISB instruction are visible to the instructions fetched after the ISB. ISB与DSB类型，不仅保证前面的指令执行，而且清空流水线，使得后续执行需要重新从内存或者Cache中取。该指令并不清空Cache。 参考 ARM®v7-M Architecture Reference Manual A answer from stackoverflow","link":"/blog/2023/02/26/memory_barrier/"},{"title":"使用Github Pages和Hexo搭建博客，利用Github Action实现自动部署","text":"搭建博客Hexo官方搭建教程就完全足够了，遇到问题再Google。 利用Github Action 实现自动部署Hexo官方部署教程也完全足够。","link":"/blog/2023/02/24/pages-hexo-action/"},{"title":"正则表达式","text":"前言正则表达式可以说是目前用过的知识工具里面性价比最高的，该工具的功能只有一个: 文本模式匹配。但是由于网页源代码、后端代码、小说和工作文档全部采用的实际是文本方式，所以正则表达式在这些领域均存在用武之地。 用法核心用法就是写出符合目标文本类的匹配特征，因此从以下4个方面来描述特征。 字符类用于描述字符。 特征字符 特征功能描述 [xyz] xyz中任一字符 [x-z] x-z中任一字符 [^xyz] 非xyz中的字符 . 任一字符(不包括换行符，取决于flag设置) \\d 数字，等价于[0-9] \\D 非数字 \\w 拉丁字母表内字符，等价于[A-Za-z0-9_](注意包括下划线) \\W 非拉丁字母表内字符 \\s 空白字符，等效于[\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] \\S 非空白字符 \\t 制表符 \\r 回车符 \\n 换行符 \\v 垂直制表符 \\f 进纸符 [\\b] 退格符 \\0 NUL字符 \\cX 控制字符表示(不常用) \\xhh 指明字符其数为hh \\uhhhh or \\u{hhhh} or \\u{hhhhh} Unicode字符 \\ 表示后面的字符应特殊对待，例如用\\\\来匹配文本中的\\ x|y x或者y 断言类 断言字符 断言功能描述 ^ 匹配字符串的开始 $ 匹配字符串的结束 \\b 匹配单词边界 \\B 匹配非单词边界 x(?=y) 前向断言，表示x后面紧跟着y(这里的前向表示字符处理的前向，也就是下一个，英文为Lookahead ) x(?!y) 前向否定断言，表示x后面不跟着y (?&lt;=y)x 后向断言，表示x前面有y(这里的后向表示字符处理的后向，也就是上一个，英文为Lookbehind ) (?&lt;!y)x 后向否定断言，表示x前面没有y 分组引用类 分组引用字符 分组引用功能描述 (x) 分组，将x作为一个整体 (?:x) 非捕获分组，将x作为一个整体，但不捕获 (?&lt;name&gt;x) 命名分组，将x作为一个整体，命名为name \\n 引用第n个分组，n从1开始 \\k&lt;name&gt; 引用名为name的分组 量词类 量词字符 量词功能描述 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次 {n} 匹配前面的子表达式n次 {n,} 匹配前面的子表达式至少n次 {n,m} 匹配前面的子表达式至少n次，至多m次 *? 匹配前面的子表达式零次或多次，非贪婪模式 注意事项 (?:x)和(?=x)的相同点和区别 相同点：都是非捕获分组，括号内的x都不会作为一个单独的分组出现在结果里；区别：正则的返回结果一般会包括整体结果和分组结果两部分。(?:x)是非捕获分组，会出现整体结果里，而(?=x)是断言，不会出现整体结果里。另外，(x)是捕获分组，会出现整体结果和分组结果里。 举个例子： 12345678import res = &quot;abcab&quot;rst = re.search(r&quot;a(?:b)&quot;, s) # &lt;re.Match object; span=(0, 2), match='ab'&gt;assert len(rst.groups()) == 0rst = re.search(r&quot;a(?=b)&quot;, s) # &lt;re.Match object; span=(0, 1), match='a'&gt;assert len(rst.groups()) == 0rst = re.search(r&quot;a(b)&quot;, s) # &lt;re.Match object; span=(0, 2), match='ab'&gt;assert len(rst.groups()) == 1 前向和后向 顺着字符处理方向为前向，反之为后向 不同语言对于flag的设置 一般来说，flag的设置是为了控制匹配的行为，比如是否区分大小写、是否匹配换行符等。不同语言对于flag的设置不同。 比如python中的re模块，flag的设置是通过re.I、re.M等来设置的。 在javascript中，flag的设置是通过/i、/m等来设置的。这里需要注意的是，python中的re.I和javascript中的/i是等价的，都表示忽略大小写。 在Rust中，flag的设置是通过在正则表达式中加入(?i)等来进行设置的。 参考MDN Regular Expressions","link":"/blog/2023/02/28/regular_expression/"}],"tags":[{"name":"编程","slug":"编程","link":"/blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"c","slug":"c","link":"/blog/tags/c/"},{"name":"健康","slug":"健康","link":"/blog/tags/%E5%81%A5%E5%BA%B7/"},{"name":"运维","slug":"运维","link":"/blog/tags/%E8%BF%90%E7%BB%B4/"},{"name":"工具","slug":"工具","link":"/blog/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[],"pages":[]}